const e=["debug","info","warn","error","none"];const t=new class{constructor(e="none"){this.level=e}setLevel(e){this.level=e}coerceLevel(t){return e.includes(t.toLocaleUpperCase())?t.toLocaleUpperCase():"info"}log(e,t,...i){const n=this.coerceLevel(e);if(!this.shouldLog(n))return;(0,console[n])(`[${n.toUpperCase()}] ${t}`,...i)}debug(e,...t){this.log("debug",e,...t)}info(e,...t){this.log("info",e,...t)}warn(e,...t){this.log("warn",e,...t)}error(e,...t){this.log("error",e,...t)}shouldLog(e){const t=["debug","info","warn","error","none"],i=t.indexOf(e);return t.indexOf(this.level)<=i&&"none"!==this.level&&"none"!==e}};class i{constructor(){this.requestCounter=0,this.requestCallbacks=new Map,this.initPromise=null,this.worker=new Worker(new URL("./worker.js",import.meta.url),{type:"module"}),this.worker.onmessage=this.handleWorkerMessage.bind(this),this.worker.onerror=this.handleWorkerError.bind(this),t.info("WorkerClient instantiated"),t.debug("WorkerClient",this.worker)}initialize(){return this.initPromise||(this.initPromise=this.sendSingleMessage("init")),this.initPromise}handleWorkerLogs(e){const{type:i,level:n,message:s,...r}=e.data;t.log(n,s,...r)}handleWorkerError(e){t.error("Worker error",e)}handleWorkerMessage(e){const{type:i,requestId:n,...s}=e.data;"log"===i&&this.handleWorkerLogs(e.data);const r=this.requestCallbacks.get(n);t.debug("WorkerClient - handleWorkerMessage",e.data),r?r(s):t.warn("WorkerClient - handleWorkerMessage - received message with no callback",n,e.data)}sendSingleMessage(e,i){return new Promise(((n,s)=>{const r=++this.requestCounter;t.debug("WorkerClient - sendSingleMessage",r,e,i),this.requestCallbacks.set(r,(e=>{this.requestCallbacks.delete(r),t.debug("WorkerClient - sendSingleMessage - response",r,e),e.data?n(e.data):e.error?s(e.error):t.warn("WorkerClient - sendSingleMessage - malformed response",r,e)})),this.worker.postMessage({type:e,payload:i,requestId:r})}))}rpcStream(e,i,n,s,r,a=()=>{}){const o=++this.requestCounter;t.debug("WorkerClient - rpcStream",o,e,i,n);let l=()=>{},c=!1;const h=new Promise((e=>{l=()=>{c?e():setTimeout((()=>l()),0)}}));return this._rpcStreamInner(o,e,i,n,s,r,a,h).then((()=>{c=!0})),l}async _rpcStreamInner(e,t,i,n,s,r,a=()=>{},o){this.requestCallbacks.set(e,(t=>{void 0!==t.error?r(t.error):void 0!==t.data?s(t.data):void 0!==t.end&&(this.requestCallbacks.delete(e),a())})),this.worker.postMessage({type:"rpc",payload:{module:t,method:i,body:n},requestId:e}),o.then((()=>{this.worker?.postMessage({type:"unsubscribe",requestId:e}),this.requestCallbacks.delete(e)}))}rpcSingle(e,i,n){return t.debug("WorkerClient - rpcSingle",e,i,n),new Promise(((t,s)=>{this.rpcStream(e,i,n,t,s)}))}cleanup(){this.worker.terminate(),this.initPromise=null,this.requestCallbacks.clear()}_getRequestCounter(){return this.requestCounter}_getRequestCallbackMap(){return this.requestCallbacks}}class n{constructor(e){this.client=e}async redeemEcash(e){await this.client.rpcSingle("mint","reissue_external_notes",{oob_notes:e,extra_meta:null})}async reissueExternalNotes(e,t){return await this.client.rpcSingle("mint","reissue_external_notes",{oob_notes:e,extra_meta:t})}subscribeReissueExternalNotes(e,t=()=>{},i=()=>{}){return this.client.rpcStream("mint","subscribe_reissue_external_notes",{operation_id:e},t,i)}async spendNotes(e,t,i,n){return await this.client.rpcSingle("mint","spend_notes",{min_amount:e,try_cancel_after:t,include_invite:i,extra_meta:n})}async validateNotes(e){return await this.client.rpcSingle("mint","validate_notes",{oob_notes:e})}async tryCancelSpendNotes(e){await this.client.rpcSingle("mint","try_cancel_spend_notes",{operation_id:e})}subscribeSpendNotes(e,t=()=>{},i=()=>{}){return this.client.rpcStream("mint","subscribe_spend_notes",{operation_id:e},(e=>t(e)),i)}async awaitSpendOobRefund(e){return await this.client.rpcSingle("mint","await_spend_oob_refund",{operation_id:e})}}class s{constructor(e){this.client=e}async getBalance(){return await this.client.rpcSingle("","get_balance",{})}subscribeBalance(e=()=>{},t=()=>{}){return this.client.rpcStream("","subscribe_balance_changes",{},(t=>e(parseInt(t))),t)}}class r{constructor(e){this.client=e}async createInvoiceWithGateway(e,t,i=null,n={},s){return await this.client.rpcSingle("ln","create_bolt11_invoice",{amount:e,description:t,expiry_time:i,extra_meta:n,gateway:s})}async createInvoice(e,t,i=null,n={}){await this.updateGatewayCache();const s=await this._getDefaultGatewayInfo();return await this.client.rpcSingle("ln","create_bolt11_invoice",{amount:e,description:t,expiry_time:i,extra_meta:n,gateway:s.info})}async payInvoiceWithGateway(e,t,i={}){return await this.client.rpcSingle("ln","pay_bolt11_invoice",{maybe_gateway:t,invoice:e,extra_meta:i})}async _getDefaultGatewayInfo(){return(await this.listGateways())[0]}async payInvoice(e,t={}){await this.updateGatewayCache();const i=await this._getDefaultGatewayInfo();return await this.client.rpcSingle("ln","pay_bolt11_invoice",{maybe_gateway:i.info,invoice:e,extra_meta:t})}subscribeLnPay(e,t=()=>{},i=()=>{}){return this.client.rpcStream("ln","subscribe_ln_pay",{operation_id:e},t,i)}subscribeLnReceive(e,t=()=>{},i=()=>{}){return this.client.rpcStream("ln","subscribe_ln_receive",{operation_id:e},t,i)}async getGateway(e=null,t=!1){return await this.client.rpcSingle("ln","get_gateway",{gateway_id:e,force_internal:t})}async listGateways(){return await this.client.rpcSingle("ln","list_gateways",{})}async updateGatewayCache(){return await this.client.rpcSingle("ln","update_gateway_cache",{})}}class a{constructor(e){this.client=e}async hasPendingRecoveries(){return await this.client.rpcSingle("","has_pending_recoveries",{})}async waitForAllRecoveries(){await this.client.rpcSingle("","wait_for_all_recoveries",{})}subscribeToRecoveryProgress(e,t){return this.client.rpcStream("","subscribe_to_recovery_progress",{},e,t)}}class o{constructor(e){this.client=e}async getConfig(){return await this.client.rpcSingle("","get_config",{})}async getFederationId(){return await this.client.rpcSingle("","get_federation_id",{})}async getInviteCode(e){return await this.client.rpcSingle("","get_invite_code",{peer:e})}async listOperations(){return await this.client.rpcSingle("","list_operations",{})}}const l="fm-default";class c{constructor(e=!1){this._openPromise=null,this._resolveOpen=()=>{},this._isOpen=!1,this._openPromise=new Promise((e=>{this._resolveOpen=e})),this._client=new i,this.mint=new n(this._client),this.lightning=new r(this._client),this.balance=new s(this._client),this.federation=new o(this._client),this.recovery=new a(this._client),t.info("FedimintWallet instantiated"),e||this.initialize()}async initialize(){t.info("Initializing WorkerClient"),await this._client.initialize(),t.info("WorkerClient initialized")}async waitForOpen(){return this._isOpen?Promise.resolve():this._openPromise}async open(e=l){if(await this._client.initialize(),this._isOpen)throw new Error("The FedimintWallet is already open.");const{success:t}=await this._client.sendSingleMessage("open",{clientName:e});return t&&(this._isOpen=!!t,this._resolveOpen()),t}async joinFederation(e,t=l){if(await this._client.initialize(),this._isOpen)throw new Error("The FedimintWallet is already open. You can only call `joinFederation` on closed clients.");(await this._client.sendSingleMessage("join",{inviteCode:e,clientName:t})).success&&(this._isOpen=!0,this._resolveOpen())}async cleanup(){this._openPromise=null,this._isOpen=!1,this._client.cleanup()}isOpen(){return this._isOpen}setLogLevel(e){t.setLevel(e),t.info(`Log level set to ${e}.`)}}export{c as FedimintWallet};
//# sourceMappingURL=index.js.map
